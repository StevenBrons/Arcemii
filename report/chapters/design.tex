\documentclass[../main.tex]{subfiles}

\begin{document}
\pagebreak

\section{Design}
In this section we give a global and detailed description of the design of Arcemii. Furthermore we give a justification for our design choices.

	\subsection{Global design}

    \subsection{Detailed design}
    In this section we give a detailed description of the design in terms of classes, methods and attributes.

        \subsubsection{Server-client relation}
        Arcemii makes use of a server and clients to enable the possibility for playing the game in multiplayer mode. In this section we will describe the most important details of this server client relation.

        Arcemii can be played in two different modes: offline and online mode (singleplayer and multiplayer). In both cases we run a server. When playing in offline mode the server is ran on the background of the mobile phone. When playing in online mode the server is ran on a dedicated server which can be connected to through the internet. Apart from this the only real difference between singleplayer and multiplayer mode is to which ip the mobile phone will try to connect. In singleplayer mode this is the so called \texttt{loop back address}, also know as \texttt{localhost} or \texttt{127.0.0.1}, whereas the multiplayer mode tries to connect to the ip of the dedicated server. 

        \paragraph{Server} 
        Let's start with a detailed description of the server. The server-side has four classes: \texttt{ArcemiiServer}, \texttt{Server}, \texttt{ServerGameHandler} and \texttt{Console}. 
        
        Since the server needs to be able to run on its own we have a \texttt{main} method in the \texttt{ArcemiiServer} class. This method creates a new object of all the other classes to start the server. This class also contains a \texttt{stop} method which stops the \texttt{Server} and \texttt{ServerGameHandler} classes from running. When the server is ran on a dedicated machine we can just run the program separately from the rest of the application. When the server is ran on the background of the mobile phone we just call the \texttt{main} method which simulates the exact same behavior, but then locally.

        The first class we instantiate when we run the server is the \texttt{Console} class. This class creates a terminal interface for interaction with the server. This is very useful when the server is ran on a dedicated machine to enable some control over the program. The console has three commands at the moment: \texttt{help}, \texttt{stop} and \texttt{log}. The \texttt{help} command gives a list of all the available commands. The \texttt{stop} command terminates the program. And the \texttt{log} command toggles the logging on and off. The logging is very useful for debugging the server. All the classes in the server call the method \texttt{log} in the console to send debug information.

        The second class we instantiate is the \texttt{ServerGameHandler} class. This class, as the name already says, handles all the game logic on the server-side. When this class starts it creates a new thread which sends an update message to every party on the server every tick (which is at the moment of writing this section 20 ticks per second). Apart from this there are two very important methods in this class, namely: \texttt{addPlayer} and \texttt{handlePlayerInput}. When the first method is called a new thread is created which listens for messages coming from that specific client. Every time a message arrives the second method is called to handle the message from the client. This method calls the appropriate method for all the possible messages. The messages are all a subclass of the abstract class \texttt{Message}. Some examples of messages are: \texttt{CreatePartMessage} to indicate to the server that the client wants to create a party, \texttt{JoinPartyMessage} to indicate to the server that the client wants to join a specific party and the \texttt{ActionMessage} to indicate which actions the player wants to execute while playing the game.

        The last class we instantiate is the \texttt{Server} class. This class continuously listens for new clients, creates a connection with these clients and adds the client to the \texttt{ServerGameHandler}. In order to prevent overloading of the server we also check if there is already a client on the server with the same ip-address. If this is the case the old client will be removed since this one is now replaced by the new client. This reduces the load on the server, because now the server does not have to listen for messages coming from the old client anymore. Note that we have an exception for the \texttt{loop back address} to make it possible to connect with multiple emulators to the server for testing purposes.

        \paragraph{Client}
        Here we will give a detailed description of the client. The client-side has two classes: \texttt{Connection} and \texttt{ClientGameHandler}.

        The first class which will be instantiated already from the \texttt{MainActivity} is the singleton \texttt{ClientGameHandler} class. The first thing this class does is create a new connection in either offline or online mode, more about that in the next sub-paragraph. When this connection is created the client starts listening for messages from the server. This works exactly the same as on the server. We listen for messages and handle the messages with the \texttt{handleInput} method. Next up the \texttt{ClientGameHandler} starts a listener for a change is server mode (offline/online), since it is possible to change this setting in the \texttt{SettingsActivity}. Whenever a change a server mode is detected the \texttt{ClientGameHandler} stops the old connection and starts a new one. The last thing the \texttt{ClientGameHandler} does when instantiated is start the \texttt{gameLoop} method. This method draws the game on the screen and gets the actions of the player and sends these to the server every tick.

        The second and last class which will be instantiated is the \texttt{Connection} class. This class either starts a connection with the online server or starts a server on the background and connects to this server. The ip-address of the server is set according to the server mode. This class contains the very important method \texttt{sendMessage} which is called whenever the client wants to send a message to the server. This class also contains a \texttt{stop} method which is very important to prevent memory leaks (due to not stopped threads) and to be able to start a new connection with a server. 

        \subsubsection{Parties}
        The server keeps track of all the clients using parties. The usage of parties enables the clients to play with their friends. Whenever a client is connected to the server the client can \texttt{create} or \texttt{join} a new party. This party gets assigned a random so called \texttt{party id} which can be used by the players to identify their party and join the party of their friends.
        
        As said in section \ref{sec: game logic} every party gets updated per game tick. We also want to use this update message to determine whether the client is still connected to the server. So upon connection with the server the client gets assigned a party just for that client. The game update messages from the server send to this party every game tick can then be used to determine the connection status. Note that the connection status does not make use of this feature yet, but this is for future implementations.

        A client can be in one party at the time. When the client joins a new party it first gets removed from the previous party. The party also uses the ready status of all the clients to determine if the master of a party can start a new game. This is only possible when all the clients in the party are ready (except for the master, the master is set ready automatically when it send the \texttt{StartGameMessage} to the server).

		\subsubsection{Level Rendering}
        \paragraph{GameView (\tiny client/view/GameView.java\normalsize)}
        The rendering of the level with all it's entities is done in the GameView class. GameView extends the standard Android View, therefore it has to be assigned to a layout. This is done within the GameActivity class (\tiny client/activities/GameActivity.java: onCreate\normalsize). After it is assigned to a layout the init() function is called to initialize all objects used in rendering of the GameView, using the dimensions of the layout. Then two functions are used to render levels: updateLevel and onDraw. \texttt{updateLevel(Level)} prepares a level to be drawn by converting it's tiles and entities to RenderItem's, and figuring out in which order to draw them. \texttt{onDraw(Canvas)} then takes these RenderItem's and draws them to the canvas, in such a way that the player is centered. Locks are used between these functions because onDraw is executed on a different thread compared to updateLevel and they both use the renderItems list.

        \paragraph{RenderItem (\tiny client/view/RenderItem.java\normalsize)} All aspects of rendering a single texture are handled in the RenderItem class. A RenderItem contains the following attributes: \texttt{texture} defines which bitmap to draw; \texttt{x,y} defines the position where the texture should be drawn; \texttt{refX,refY} defines the position within the bitmap used for alignment; \texttt{layer} defines the layer on which this object is drawn; \texttt{animationOffset} the number of frames this object's animation is ahead of the default animation; \texttt{rotation} defines the number of degrees to turn this image counter-clockwise; \texttt{flip} defines whether this image should be flipped horizontally.\\
        The function \texttt{compareTo(RenderItem)} determines which of two RenderItems should be drawn first. The function \texttt{renderTo(Canvas)} renders this RenderItem to the canvas, applying all transformations specified.

        \paragraph{Texture (\tiny client/view/Texture.java\normalsize)} This class handles the loading of textures, to prevent a Bitmap to be loaded every time it needs to be drawn. It has a HashMap that stores all textures using a String as a key. The key corresponds to the path of the texture within the assets/sprites folder. \texttt{getTexture} is a factory method that loads a Bitmap to the HashMap if necessary and returns the corresponding Texture. \texttt{getBitmap} returns the Bitmap associated with a Texture object.

        \paragraph{Animation (\tiny client/view/Animation.java\normalsize)} Animation is a decoration of the Texture class, in order to be able to handle animations. It's \texttt{getBitmap} function takes the current time into account to return a certain frame of the animation.

        \paragraph{Generation of RenderItems} RenderItems are created in the classes of the objects they visualize (\tiny shared/entities/\dots; shared/tiles/\dots\normalsize). This was done to prevent shadow classes for each entity that only generates RenderItems. Unfortunately the objects are shared between the server and client, which means that a server can't be run without compiling all client stuff with it. We didn't find it worthwhile to fix this before the deadline, as we would run the server from within Android Studio for testing. 

        
        \subsubsection{Game logic}\label{sec: game logic}
        Before we can explain how the game-logic works a few definitions have to be given:

        \paragraph{Tile} A Tile is a building-block of the world. It can either be solid, or non solid, meaning entities can either move through it or not. A few of the tile-types in Arcemii are:
        \begin{description}
            \item[Wall] A solid tile.
            \item[Empty] A non-solid tile.
            \item[Void] A tile outside of the bounds of the level.
            \item[Start] A tile on which players are spawned at the start of a game.
            \item[Finish] A tile denoting the final room of a level.
        \end{description}

        \paragraph{Entity} An entity is a non-tile game-object with a specific position within a level. An entity's position is not limited to whole numbers (where the a tile's position is). Every entity is identified by an unique UUID. A few of the entity-types in Arcemii are:
        \begin{description}
            \item[Player] Controlled by the actual players of the game.
            \item[Skeleton] Enemy of player, shoot arrows and flees from the player.
            \item[Slime] Enemy of player, attacks player by jumping toward them.
            \item[Boss] Enemy of player, teleports and summons slime entities.
            \item[Arrow] Flies in certain direction, can either hit player or non-player entities. Deals damage to entities it hits.
        \end{description}

        \paragraph{Level}
        A level contains a grid of tiles (instances of the \texttt{Tile} class). These tiles represent the world. Furthermore the level contains a list of entities (instances of the 
        \texttt{Entity} class).

        \paragraph{Ability}
        The game Arcemii is based upon the notion of abilities. Player can choose the abilities they want to use in-game. Every entity has abilities. An ability can be \textbf{executed}. When a ability is executed, its action is performed on the level or the entity that performed the ability. A ability can be executed directly, or in some cases it can be \textbf{invoked} first. If an ability is invoked, certain parameters needed to execute the abilities are set. For example: If an entity wants to execute the \texttt{Move} ability, it needs to specify in which direction it wants to move, so the entity has to invoke the ability with a \texttt{direction} parameter. How invocation a execution works in practice is explained in more detail later. What follows is a list of some of the abilities present in Arcemii:
        \begin{description}
            \item[Bow] \texttt{When executed:} Create a new arrow entity. \\
            \texttt{To invoke:} The direction in which to shoot and whether to hit player is needed.
            \item[Heal] \texttt{When executed:} Heal the entity that executed the ability \\
            \texttt{To invoke:} The amount to heal is needed
            \item[Melee] \texttt{When executed:} Deals damage to entities in range of the entity that executed the ability.\\
            \texttt{To invoke:} Whether to damage players and the amount of damage is needed.
        \end{description}

        \paragraph{Game logic explanation}
        Because Arcemii is a multiplayer game, it is split into the two main sections: the server and the client. In relation to the actual game, the client acts only as the view, and a little bit as the controller part. The actual game-logic happens on the server side. The current state of the game is saved as a property of \texttt{Party}, because each party has their own game-state. This game-state is saved in the shared object \texttt{Level}. The level class contains the current world-state of the game. The server-gameloop updates all parties every \texttt{TICKSPEED} amount of time. When a party is in-game, and \texttt{update} is called the following happens:

        \begin{enumerate}
            \item \textbf{Invoke} The \texttt{invokeAll} method of all entities except for players is called. This method invokes all abilities that the entities want to execute (based upon their A.I.). All executed abilities are saved in an \texttt{actions} list. The actions players want to take are added to their respective \texttt{actions} when they submit new actions to the server.
            \item \textbf{Execute} All entities now have a list of the actions they want to execute. The execute method of these actions (abilities) are called and the changes are recorded.
            \item \textbf{Send updates} All changed entities are collected and sent to all party members.
        \end{enumerate}
        
        
	\subsection{Design justification}

\end{document}