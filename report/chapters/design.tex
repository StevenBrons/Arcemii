\documentclass[../main.tex]{subfiles}

\begin{document}
\pagebreak

\section{Design}
In this section we give a global and detailed description of the design of Arcemii. Furthermore we give a justification for our design choices.

	\subsection{Global design}

    \subsection{Detailed design}
    In this section we give a detailed description of the design in terms of classes, methods and attributes.

        \subsubsection{Server-client relation}
        Arcemii makes use of a server and clients to enable the possibility for playing the game in multiplayer mode. In this section we will describe the most important details of this server client relation.

        Arcemii can be played in two different modes: offline and online mode (singleplayer and multiplayer). In both cases we run a server. When playing in offline mode the server is ran on the background of the mobile phone. When playing in online mode the server is ran on a dedicated server which can be connected to through the internet. Apart from this the only real difference between singleplayer and multiplayer mode is to which ip the mobile phone will try to connect. In singleplayer mode this is the so called \texttt{loop back address}, also know as \texttt{localhost} or \texttt{127.0.0.1}, whereas the multiplayer mode tries to connect to the ip of the dedicated server. 

        \paragraph{Server} 
        Let's start with a detailed description of the server. The server-side has four classes: \texttt{ArcemiiServer}, \texttt{Server}, \texttt{ServerGameHandler} and \texttt{Console}. 
        
        Since the server needs to be able to run on its own we have a \texttt{main} method in the \texttt{ArcemiiServer} class. This method creates a new object of all the other classes to start the server. This class also contains a \texttt{stop} method which stops the \texttt{Server} and \texttt{ServerGameHandler} classes from running. When the server is ran on a dedicated machine we can just run the program separately from the rest of the application. When the server is ran on the background of the mobile phone we just call the \texttt{main} method which simulates the exact same behavior, but then locally.

        The first class we instantiate when we run the server is the \texttt{Console} class. This class creates a terminal interface for interaction with the server. This is very useful when the server is ran on a dedicated machine to enable some control over the program. The console has three commands at the moment: \texttt{help}, \texttt{stop} and \texttt{log}. The \texttt{help} command gives a list of all the available commands. The \texttt{stop} command terminates the program. And the \texttt{log} command toggles the logging on and off. The logging is very useful for debugging the server. All the classes in the server call the method \texttt{log} in the console to send debug information.

        The second class we instantiate is the \texttt{ServerGameHandler} class. This class, as the name already says, handles all the game logic on the server-side. When this class starts it creates a new thread which sends an update message to every party on the server every tick (which is at the moment of writing this section 20 ticks per second). Apart from this there are two very important methods in this class, namely: \texttt{addPlayer} and \texttt{handlePlayerInput}. When the first method is called a new thread is created which listens for messages coming from that specific client. Every time a message arrives the second method is called to handle the message from the client. This method calls the appropriate method for all the possible messages. The messages are all a subclass of the abstract class \texttt{Message}. Some examples of messages are: \texttt{CreatePartMessage} to indicate to the server that the client wants to create a party, \texttt{JoinPartyMessage} to indicate to the server that the client wants to join a specific party and the \texttt{ActionMessage} to indicate which actions the player wants to execute while playing the game.

        The last class we instantiate is the \texttt{Server} class. This class continuously listens for new clients, creates a connection with these clients and adds the client to the \texttt{ServerGameHandler}. In order to prevent overloading of the server we also check if there is already a client on the server with the same ip-address. If this is the case the old client will be removed since this one is now replaced by the new client. This reduces the load on the server, because now the server does not have to listen for messages coming from the old client anymore. Note that we have an exception for the \texttt{loop back address} to make it possible to connect with multiple emulators to the server for testing purposes.

        \paragraph{Client}
        Here we will give a detailed description of the client. The client-side has two classes: \texttt{Connection} and \texttt{ClientGameHandler}.

        The first class which will be instantiated already from the \texttt{MainActivity} is the singleton \texttt{ClientGameHandler} class. The first thing this class does is create a new connection in either offline or online mode, more about that in the next sub-paragraph. When this connection is created the client starts listening for messages from the server. This works exactly the same as on the server. We listen for messages and handle the messages with the \texttt{handleInput} method. Next up the \texttt{ClientGameHandler} starts a listener for a change is server mode (offline/online), since it is possible to change this setting in the \texttt{SettingsActivity}. Whenever a change a server mode is detected the \texttt{ClientGameHandler} stops the old connection and starts a new one. The last thing the \texttt{ClientGameHandler} does when instantiated is start the \texttt{gameLoop} method. This method draws the game on the screen and gets the actions of the player and sends these to the server every tick.

        The second and last class which will be instantiated is the \texttt{Connection} class. This class either starts a connection with the online server or starts a server on the background and connects to this server. The ip-address of the server is set according to the server mode. This class contains the very important method \texttt{sendMessage} which is called whenever the client wants to send a message to the server. This class also contains a \texttt{stop} method which is very important to prevent memory leaks (due to not stopped threads) and to be able to start a new connection with a server. 

		\subsubsection{Level Rendering}
        \paragraph{GameView (\tiny client/view/GameView.java\normalsize)}
        The rendering of the level with all it's entities is done in the GameView class. GameView extends the standard Android View, therefore it has to be assigned to a layout. This is done within the GameActivity class (\tiny client/activities/GameActivity.java: onCreate\normalsize). After it is assigned to a layout the init() function is called to initialize all objects used in rendering of the GameView, using the dimensions of the layout. Then two functions are used to render levels: updateLevel and onDraw. \texttt{updateLevel(Level)} prepares a level to be drawn by converting it's tiles and entities to RenderItem's, and figuring out in which order to draw them. \texttt{onDraw(Canvas)} then takes these RenderItem's and draws them to the canvas, in such a way that the player is centered. Locks are used between these functions because onDraw is executed on a different thread compared to updateLevel and they both use the renderItems list.

        \paragraph{RenderItem (\tiny client/view/RenderItem.java\normalsize)} All aspects of rendering a single texture are handled in the RenderItem class. A RenderItem contains the following attributes: \texttt{texture} defines which bitmap to draw; \texttt{x,y} defines the position where the texture should be drawn; \texttt{refX,refY} defines the position within the bitmap used for alignment; \texttt{layer} defines the layer on which this object is drawn; \texttt{animationOffset} the number of frames this object's animation is ahead of the default animation; \texttt{rotation} defines the number of degrees to turn this image counter-clockwise; \texttt{flip} defines whether this image should be flipped horizontally.\\
        The function \texttt{compareTo(RenderItem)} determines which of two RenderItems should be drawn first. The function \texttt{renderTo(Canvas)} renders this RenderItem to the canvas, applying all transformations specified.

        \paragraph{Texture (\tiny client/view/Texture.java\normalsize)} This class handles the loading of textures, to prevent a Bitmap to be loaded every time it needs to be drawn. It has a HashMap that stores all textures using a String as a key. The key corresponds to the path of the texture within the assets/sprites folder. \texttt{getTexture} is a factory method that loads a Bitmap to the HashMap if necessary and returns the corresponding Texture. \texttt{getBitmap} returns the Bitmap associated with a Texture object.

        \paragraph{Animation (\tiny client/view/Animation.java\normalsize)} Animation is a decoration of the Texture class, in order to be able to handle animations. It's \texttt{getBitmap} function takes the current time into account to return a certain frame of the animation.

        \paragraph{Generation of RenderItems} RenderItems are created in the classes of the objects they visualize (\tiny shared/entities/\dots; shared/tiles/\dots\normalsize). This was done to prevent shadow classes for each entity that only generates RenderItems. Unfortunately the objects are shared between the server and client, which means that a server can't be run without compiling all client stuff with it. We didn't find it worthwhile to fix this before the deadline, as we would run the server from within Android Studio for testing. 

	\subsection{Design justification}

\end{document}